
=head2 wait_for_systeminstaller

Wait for status messages of System Installer and apply timeout on
booting to make sure we react on a system that is stuck while booting
into system installer. The time needed to install a system can vary
widely thus no timeout for installation is applied.

@param file handle - read from this file handle


@return success - 0
@return error   - error string

=cut 

sub wait_for_systeminstaller
{
        my ($self,$fh) = @_;

        my $timeout = $self->cfg->{times}{boot_timeout};
        eval {
                local $SIG{ALRM}=sub{die("timeout of $timeout seconds reached while booting system installer");};
                $timeout=0 if not $timeout; # to get rid of warnings in case get_timeout failed above
                alarm($timeout);
                
                my $msg = <$fh>;
                chomp $msg;
        
                if ($msg!~/start-install/) {
                        $self->log->error( qq(Expected start-install signal from System Installer but received "$msg"));
                        die qq(Expected start-install signal from System Installer but received "$msg");
                }
                $self->log->debug("Installation started for testrun ".$self->testrun);
        };
        alarm(0);
        return $@ if $@;

        my $msg=<$fh>;

        my ($state, undef, $error) = $msg =~/(end|error)-install(:(.+))?/ or 
                  do {
                          $self->log->error(qq(Can't parse message "$msg" received from system installer, expected ),
                                            qq("end-install" or "error-install"));
                          return( qq(Can't parse message "$msg" received from system installer, expected ),
                                  qq("end-install" or "error-install"));
                  };

                if ($state eq 'end') {
                        $self->log->debug("Installation finished for testrun ".$self->testrun);
                        return 0;
                } elsif ($state eq 'error') {
                        return $error;
                }
}


sub get_message($fh)
{
        $sock  = $fh->accept() if $fh->can('accept');
        while ($msg .= <$sock>) {} 
        return $msg;
}



=head2 wait_for_testrun

Wait for start and end of a test program. Put start and end time into
database. The function also recognises errors send from the PRC. It returns an
array that can be handed over to tap_report_send. Optional file handle is used
for easier testing.

@param int - testrun id
@param file handle - read from this handle

@return reference to report array

=cut

sub wait_for_testrun
{
        my ($self, $fh) = @_;
        my ($prc_status, $prc_started, $prc_stopped, $prc_count, $error_occured)=(undef, 0, 0, undef, 0);
      

        # eval block used for timeout
        eval{
                my $timeout = $self->cfg->{times}{boot_timeout};
                
                alarm($timeout);
                $SIG{ALRM}=sub{$error_occured=1;die("timeout for booting test system ($timeout seconds) reached.\n");};

                no warnings 'io';
        MESSAGE:
                while (my $msg=<$fh>) {
                        use warnings;
                        chomp $msg;
                        #        prc_number:0,end-testprogram,prc_count:1
                        my ($number, $status, undef, $error, $count) = $msg =~/prc_number:(\d+),(start|end|error)-testprogram(:(.+))?,prc_count:(\d+)/ 
                          or $self->log->error(qq(Can't parse message "$msg" received from test machine. I'll ignore the message.)) and next MESSAGE;
                        $self->log->debug("status $status in PRC $number, last PRC is $count");
                        
                        if (not defined($prc_count)) {
                                $prc_count = $count;
                        } elsif ($prc_count != $count) {
                                $self->log->error("Got new PRC count for testrun ".$self->testrun.", old value was $prc_count, new value is $count");
                                $prc_count = $count;
                        }


                        if (not defined($prc_status)) {
                                $timeout = $self->gettimeout($self->testrun);
                                alarm($timeout);
                                $SIG{ALRM}=sub{die("timeout for tests ($timeout seconds) reached.\n");};

                                for (my $i=0; $i<$prc_count;$i++) {
                                        $prc_status->[$i] = {start => 0, end => 0};
                                }
                        }
                        
                        if ($status eq 'start') {
                                $prc_status->[$number]->{start} = 1;
                                $prc_started++;
                        } elsif ($status eq 'end') {
                                $prc_status->[$number]->{end} = 1;
                                $prc_stopped++;
                        } elsif ($status eq 'error') {
                                $prc_status->[$number]->{end} = -1;
                                $error_occured=1;
                                $prc_status->[$number]->{error} = $error;
                                $prc_stopped++;
                        } else {
                                $self->log->error("Unknown status $status for PRC $number");
                        }
                        last MESSAGE if $prc_stopped == $count;
                }
        };
        alarm(0);

        my @report;
        if (not $error_occured) {
                @report = ({msg => "All tests finished"});
        }
        else {
                
                # save eval return value, just to be sure
                chomp $@;
                my $got_timeout = $@;
                

                my $offset=0;
                # $prc_status is undefined only if we did not get any message and were
                # kicked out by timeout
                if ($prc_status) {
                        # we got a test in virtualisation host
                        if ($prc_status->[0]->{start} != 0 or $prc_status->[0]->{end} != 0) {
                                if ($prc_status->[0]->{end} == -1) {
                                        push(@report, {error => 1, msg => $prc_status->[0]->{error}});
                                } elsif ($prc_status->[0]->{end} == 1) {
                                        push (@report, {msg => "Test on PRC 0"});
                                } elsif ($@) {
                                        push(@report, {error => 1, msg => "test on PRC 0 started but not finished: $@"});
                                } else {
                                        push(@report, {error => 1, msg => "PRC 0 has unidentifiably end status ".$prc_status->[0]->{end}});
                                        $self->log->warn("PRC 0 has unidentifiably end status ",$prc_status->[0]->{end});
                                }
                                $prc_count--;
                                $offset =1;
                        }
                        shift @$prc_status;
                        

                        for (my $i=0; $i<$prc_count;$i++) {
                                # $prc_status starts with 0, guests starts with 1
                                # offset is used when we removed 
                                my $guest=$i+1+$offset;
                                if ($prc_status->[$i]->{end} == 1) {
                                        push (@report, {msg => "Test on guest $guest"});
                                } elsif ($prc_status->[$i]->{end} == -1) {
                                        push (@report, {error => 1, msg => "guest $guest:".$prc_status->[$i]->{error}});
                                } elsif ($@) {
                                        if ($prc_status->[$i]->{end}) {
                                                if ($prc_status->[$i]->{start}) {
                                                        push(@report, {error => 1, msg => "test on guest $guest started but not finished: $@"});
                                                } else {
                                                        push(@report, {error => 1, msg => "test on guest $guest not started: $@"});
                                                }
                                        }
                                } else {
                                        push(@report, {error => 1, msg => "guest $guest has unidentifiably end status ".$prc_status->[$i]->{end}});
                                        $self->log->warn("guest $guest has unidentifiably end status ",$prc_status->[$i]->{end});
                                }
                        }
                }
                push (@report, {error=> 1, msg => $got_timeout}) if $got_timeout;
        }
        return \@report;
}
